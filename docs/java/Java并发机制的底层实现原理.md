## 1 volatile应用

### 1.1 实现原则

> volatile修饰的共享变量进行写操作的时候会在汇编代码上添加**Lock前缀**，Lock前缀的指令会在多核处理器下引发2件事情：

- 将当前处理器缓存行的数据写回到系统内存；
- 写回内存的操作会使其他CPU里缓存了该内存地址的数据无效。

第2条基于**缓存一致性**协议实现，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期。当处理器发现自己缓存行对应的内存地址被修改，则将当前处理器的缓存行设置为无效状态，重新从系统内存中读取。

**缓存一致性**又基于MESI控制协议来维护：

- M：被修改的。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且没有更新到内存中。
- E：独占的。处于这一状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致。
- S：共享的。处于这一状态的数据在多个CPU中都有缓存，且与内存一致。
- I：无效的。本CPU中的这份缓存已经无效。

### 1.2 使用优化

> Linked-TransferQueue：追加字节的的方式来优化队列出队和入队的性能。
> Doug lea使用追加64字节的方式来填满高速缓冲区的缓冲行，避免头结点和尾节点加载到同一缓存行，使头、尾节点在修改时不会互相锁定。



